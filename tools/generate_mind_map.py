"""Generate the Mind Map section for the rtrg codebase.

Scans the `rtrg/` package for top-level classes and functions and updates the
Mind Map section in `mind-map.md` between the markers:

    <!-- BEGIN AUTO-GENERATED: MIND MAP -->
    ... generated content ...
    <!-- END AUTO-GENERATED: MIND MAP -->

Usage:
    uv run python tools/generate_mind_map.py --output mind-map.md

Options:
    --root PATH          Root package directory to scan (default: rtrg)
    --output PATH        Markdown file to update (default: mind-map.md)
    --summaries          Include first-sentence summaries (docstrings) inline
                         after symbol names (default: off)
"""

from __future__ import annotations

import argparse
import ast
import datetime as _dt
import re
from collections.abc import Iterable
from pathlib import Path
from typing import Any

BEGIN_MARKER = "<!-- BEGIN AUTO-GENERATED: MIND MAP -->\n"
END_MARKER = "<!-- END AUTO-GENERATED: MIND MAP -->"


def first_sentence(text: str, max_len: int = 140) -> str:
    if not text:
        return ""
    # Normalize whitespace
    s = " ".join(text.strip().split())
    if not s:
        return ""
    # Try to cut at first sentence boundary
    match = re.search(r"(?<=[.!?])\s", s)
    sent = s[: match.end()] if match else s.split("\n", 1)[0]
    if len(sent) > max_len:
        return sent[: max_len - 3] + "..."
    return sent


def scan_file(py_path: Path) -> tuple[list[tuple[str, str]], list[tuple[str, str]]]:
    try:
        src = py_path.read_text(encoding="utf-8")
    except Exception:
        return [], []
    try:
        tree = ast.parse(src, filename=str(py_path))
    except SyntaxError:
        return [], []

    functions: list[tuple[str, str]] = []
    classes: list[tuple[str, str]] = []
    for node in tree.body:
        if isinstance(node, ast.FunctionDef | ast.AsyncFunctionDef):
            doc = ast.get_docstring(node)
            functions.append((node.name, first_sentence(doc or "")))
        elif isinstance(node, ast.ClassDef):
            doc = ast.get_docstring(node)
            classes.append((node.name, first_sentence(doc or "")))
    return functions, classes


def build_inventory(root: Path) -> dict[str, dict[str, dict[str, list[tuple[str, str]]]]]:
    """Return nested dict: domain -> module -> {classes: [], functions: []}.

    domain is the first-level directory under `root`. Files directly under `root`
    use domain="__root__".
    """
    inventory: dict[str, dict[str, dict[str, list[tuple[str, str]]]]] = {}
    for py in sorted(root.rglob("*.py")):
        # Compute relative path from root
        rel = py.relative_to(root)
        parts = rel.parts
        if len(parts) == 1:
            domain = "__root__"
            module = parts[0]
        else:
            domain = parts[0]
            module = "/".join(parts[1:])

        funcs, clss = scan_file(py)
        domain_map = inventory.setdefault(domain, {})
        module_map = domain_map.setdefault(module, {"classes": [], "functions": []})
        module_map["functions"].extend(funcs)
        module_map["classes"].extend(clss)
    return inventory


def format_symbol_list(symbols: list[tuple[str, str]], include_summaries: bool) -> str:
    if not symbols:
        return ""
    formatted: list[str] = []
    for name, summary in symbols:
        if include_summaries and summary:
            formatted.append(f"`{name}` — {summary}")
        else:
            formatted.append(f"`{name}`")
    return ", ".join(formatted)


def generate_mind_map_block(
    inventory: dict[str, dict[str, dict[str, list[tuple[str, str]]]]],
    include_summaries: bool,
    include_timestamp: bool,
) -> str:
    # Preferred domain order, with fallback alphabetical for others
    preferred = [
        "__root__",
        "core",
        "field_theory",
        "renormalization",
        "israel_stewart",
        "visualization",
        "numerics",
        "analysis",
        "symbolic",
        "production",
    ]
    domains = [d for d in preferred if d in inventory] + [
        d for d in sorted(inventory) if d not in preferred
    ]

    lines: list[str] = []
    lines.append(BEGIN_MARKER)
    lines.append("<!-- This section is auto-generated by tools/generate_mind_map.py -->")
    lines.append("## Mind Map (Modules → Classes/Functions)")
    lines.append("")
    if include_timestamp:
        ts = _dt.datetime.now(_dt.UTC).strftime("%Y-%m-%d %H:%M UTC")
        lines.append(f"Generated: {ts}")
        lines.append("")

    # Root label
    lines.append("- rtrg")

    for domain in domains:
        domain_label = "__init__.py" if domain == "__root__" else domain
        if domain == "__root__":
            modules = inventory[domain]
            for module in sorted(modules):
                lines.append(f"  - {module}")
                classes = modules[module].get("classes", [])
                functions = modules[module].get("functions", [])
                if functions:
                    lines.append(
                        "    - functions: " + format_symbol_list(functions, include_summaries)
                    )
                if classes:
                    lines.append("    - classes: " + format_symbol_list(classes, include_summaries))
            continue

        # domain header
        lines.append(f"  - {domain}")
        modules = inventory[domain]
        for module in sorted(modules):
            lines.append(f"    - {module}")
            classes = modules[module].get("classes", [])
            functions = modules[module].get("functions", [])
            if functions:
                lines.append(
                    "      - functions: " + format_symbol_list(functions, include_summaries)
                )
            if classes:
                lines.append("      - classes: " + format_symbol_list(classes, include_summaries))

    lines.append("")
    lines.append(END_MARKER)
    return "\n".join(lines)


def update_file(output: Path, block: str) -> None:
    if output.exists():
        text = output.read_text(encoding="utf-8")
        if BEGIN_MARKER in text and END_MARKER in text:
            # Replace existing block
            pattern = re.compile(
                rf"{re.escape(BEGIN_MARKER)}[\s\S]*?{re.escape(END_MARKER)}",
                re.MULTILINE,
            )
            new_text = pattern.sub(block, text)
            output.write_text(new_text, encoding="utf-8")
            return
    # Fallback: write just the block
    output.write_text(block, encoding="utf-8")


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate Mind Map for rtrg")
    ap.add_argument("--root", default="rtrg", help="Root package to scan (default: rtrg)")
    ap.add_argument(
        "--output", default="mind-map.md", help="Markdown file to update (default: mind-map.md)"
    )
    ap.add_argument(
        "--summaries",
        action="store_true",
        help="Include first-sentence summaries after symbols",
    )
    ap.add_argument(
        "--timestamp",
        action="store_true",
        help="Include a generation timestamp (omit by default for determinism)",
    )
    args = ap.parse_args()

    root = Path(args.root).resolve()
    if not root.exists() or not root.is_dir():
        raise SystemExit(f"Root directory not found: {root}")

    inventory = build_inventory(root)
    block = generate_mind_map_block(
        inventory,
        include_summaries=bool(args.summaries),
        include_timestamp=bool(args.timestamp),
    )
    update_file(Path(args.output).resolve(), block)


if __name__ == "__main__":
    main()
